## 线程池：

1.定义：
* 异步或并发执行任务程序。
* 线程池就是将线程进行池化，需要运行任务时从池中拿一个线程来执行，执行完毕，线程放回池中。
2.好处：
* 线程复用。操作系统开的线程数有限。降低创建和销毁线程资源的消耗。（new Thread，虚拟机耗费CPU。start创建线程消耗资源。线程使用过程：创建+执行+销毁）
* 提高响应速度。
* 提高线程的可管理性和提升系统的稳定性。（线程建的多耗费资源，且降低系统稳定性。虚拟机需要为线程分配内存。栈空间1M。）
3.手写线程池：
* 新建任务队列缓存。新建3个线程。
* 线程池放入5个任务。放入任务队列缓存中。线程执行的时候从任务队列中获取。
* 销毁线程池。
4.JDK中的线程池：ThreadPoolExecutor。
* 线程池各个参数的含义和四种拒绝策略以及线程池的工作机制（面试必问）

提交任务：
* execute：不会有返回值。
* submit：有返回值。
5.合理配置线程池：（面试必问）
任务的特性有关：
* CPU密集型：当前任务依赖于CPU，大量的计算任务。线程个数不要超过CPU上可以同时运行的线程个数。
* IO密集型：IO读写。尽可能配置多的线程数，机器上CPU的线程数*2。（经验）
* 混合型：如果CPU密集型和IO密集型耗的时间差不多就进行拆分，但是时间相差太多可以忽略不计，比如IO执行一个任务耗时10s，cpu执行一个任务耗时10ms。
6.Asynctask。
主线程和子线程之间的通讯：handler-----》thread+handler
Asynctask（封装thread+handler）
Asynctask优缺点？？？
用途：请求网络/下载文件（因为都需要在子线程中）
悲观锁：总是认为有线程要改我的数据，所以在修改数据之前都要抢到锁。
比如：synchronized同步锁，lock显式锁。
乐观锁：先 get 到 oldvalue 数据再写回 newvalue 数据。CAS（compare and swap：先比较数据是否等于 oldvalue 再写回 newvalue 数据）
eg：AtomicInteger。死循环。

volatile：adj易变的。
问题：需要经常从内存中读取。
作用：为实例域的同步访问提供了一种免锁机制。
因为：使用synchronized可能造成阻塞，使用Lock锁不太合适。
优点：保证数据的可见性。
缺点：不能像synchronized保证数据的正确性。不安全，不能保证对数据的修改。不能保证操作的原子性。例子：initcount。
why：volatile有线程安全问题？
JVM内存原型导致的并发安全问题。《计算机原理》
CPU有缓存。每个线程都有自己的工作内存。从主内存中读取值和写入值。每个线程只会对自己工作内存里的数据进行操作。
不加关键字：每次读取到的不是最新的数据，是该工作内存中的数据。
synchronized：每次使用count都是获取到的最新数据。同一个时刻只能有一个线程执行。
volatile：每个线程都获取的是最新数据，但是线程还是同时执行。
volatile的适用场景：只有一个线程写，其他线程都在读。（多读一写）

死锁：
线程安全公开课。

单例：
双重检查不推荐。栈内模式和饿汉模式多一点。？？加深单例模式的理解。






