## 线程池原理与AsyncTask

1.定义：

* 异步或并发执行任务程序。
* 线程池就是将线程进行池化，需要运行任务时从池中拿一个线程来执行，执行完毕，线程放回池中。

2.好处：

* 线程复用。操作系统开的线程数有限。降低创建和销毁线程资源的消耗。（new Thread，虚拟机耗费CPU。start创建线程消耗资源。线程使用过程：创建+执行+销毁）
* 提高响应速度。
* 提高线程的可管理性和提升系统的稳定性。（线程建的多耗费资源，且降低系统稳定性。虚拟机需要为线程分配内存。栈空间1M。）

3.手写线程池：

* 新建任务队列缓存。新建3个线程。
* 线程池放入5个任务。放入任务队列缓存中。线程执行的时候从任务队列中获取。
* 销毁线程池。

4.JDK中的线程池：ThreadPoolExecutor。

* 线程池各个参数的含义和四种拒绝策略以及线程池的工作机制（重点）

提交任务：

* execute：不会有返回值。
* submit：有返回值。

5.合理配置线程池：（重点）

任务的特性有关：

* CPU密集型：当前任务依赖于CPU，大量的计算任务。线程个数不要超过CPU上可以同时运行的线程个数。
* IO密集型：IO读写。尽可能配置多的线程数，机器上CPU的线程数*2。（经验）
* 混合型：如果CPU密集型和IO密集型耗的时间差不多就进行拆分，但是时间相差太多可以忽略不计，比如IO执行一个任务耗时10s，cpu执行一个任务耗时10ms。

6.Asynctask。

主线程和子线程之间的通讯：handler-----》thread+handler

Asynctask（封装thread+handler）

Asynctask优缺点？？？

用途：请求网络/下载文件（因为都需要在子线程中）

悲观锁：总是认为有线程要改我的数据，所以在修改数据之前都要抢到锁。

比如：synchronized同步锁，lock显式锁。

乐观锁：先 get 到 oldvalue 数据再写回 newvalue 数据。CAS（compare and swap：先比较数据是否等于 oldvalue 再写回 newvalue 数据）
eg：AtomicInteger。死循环。





