## JVM

### 目录

* 1.Java字节码如何在虚拟机里运行
* 2.Java虚拟机如何加载Java类
* 3.Java虚拟机如何进行垃圾回收
* 4.Java的内存模型

### 1.Java字节码是如何在虚拟机里运行的？

从虚拟机视角来看：

首先编译器编译：java文件编译成字节码class文件。

随后类加载器加载：字节码文件加载到虚拟机内存中。类加载机制。

最后解释器即虚拟机解释执行：加载后的Java类存放于方法区中，实际运行时虚拟机会执行方法区内的代码。虚拟机在内存中有三块区域：堆(字符串常量池在堆内存中)，栈，方法区；堆和栈用来存储运行时数据；栈分为面向Java的Java方法栈，面向C++d的native本地方法栈，存放每个线程执行位置的PC寄存器。

从硬件视角来看：

Java字节码无法直接执行，Java虚拟机需要将字节码翻译成机器码。

翻译过程有两种：

* 解释执行，每解析一条字节码，便翻译成机器码执行；
* 即时编译，将整个方法中包含的字节码统一翻译成机器码而后执行。

HotSpot默认采用混合模式，综合了解释执行和即时编译的优点，先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

---

我将以HotSpot虚拟机为例，从虚拟机以及底层硬件两个角度，来分享解析。

1、从虚拟机视角来看

执行Java代码首先需要将它编译而成的class文件加载到Java虚拟机中。加载后的Java类会被存放于方法区中。实际运行时，虚拟机会执行方法区内的代码。

如果你熟悉X86的话，你会发现这和段式内存管理中的代码段类似。而且，Java虚拟机同样也在内存中划分出堆和栈来存储运行时数据。不同的是，Java虚拟机会将栈细分为面向Java方法的Java方法栈，面向用C++写的native方法的本地方法栈，以及存放各个线程执行位置的PC寄存器。

![image](https://github.com/2211785113/Blog/blob/master/images/jvm1.jpg)

在运行过程中，每当调用进入一个Java方法，Java虚拟机会在当前线程的Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且Java虚拟机不要求栈帧在内存空间里连续分布。

当退出当前执行的方法时，不管是正常返回还是异常返回，Java虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。

2、从硬件视角来看

Java字节码无法直接执行。因此，Java虚拟机需要将字节码翻译成机器码。

在HotSpot里面，上述翻译过程有两种形式：第一种是解释执行，相当于同声传译，即每解析一条字节码，便翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），则相当于线下翻译，即将整个方法中所包含的字节码统一翻译成机器码后在执行。

![image](https://github.com/2211785113/Blog/blob/master/images/jvm2.jpg)

前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

### 2.Java虚拟机是如何加载Java类的？

** 概括 **
加载，链接，初始化。

启动类加载器—>扩展类加载器—>应用类加载器。

加载：查找字节流，并创建类。Java虚拟机中，类加载器使用双亲委派模型，接收到加载请求时，将请求转发给父类加载器。

链接：将创建成的类合并到Java虚拟机中，使之能够执行。链接分为验证，准备和解析三个阶段。验证被加载类是否满足Java虚拟机约束，为被加载类静态字段分配内存，将被加载类中的符号引用解析成为实际引用。Java虚拟机规范并不要求解析阶段一定要在链接步骤中完成。

初始化：为标记为常量值的字段赋值，以及执行<clinit>方法。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

---

Java虚拟机加载Java类的过程可分为加载、链接以及初始化三大步骤。

加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在Java虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。

![image](https://github.com/2211785113/Blog/blob/master/images/jvm3.jpg)

链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段，分别完成“验证被加载类是否满足Java虚拟机约束”，“为被加载类静态字段分配内存”，以及“将被加载类中的符号引用解析成为实际引用”的工作。其中，Java虚拟机规范并不要求解析阶段一定要在链接步骤中完成。

初始化，则是为标记为常量值的字段赋值，以及执行<clinit>方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

### 3.Java虚拟机是如何进行垃圾回收的？

怎么样GC(垃圾回收器)回收：引用计数回收，新建对象计数+1，引用为空计数-1，为0时进行回收；可达性分析回收(Java虚拟机)。

可达性分析：Java虚拟机中的垃圾回收器采用可达性分析来探索所有分析的对象。从一系列GC Roots出发，边标记边探索所有被引用的对象。为了防止在标记过程中堆栈状态被改变，Java虚拟机采用安全点机制来实现Stop-The-World操作，暂停其他非垃圾回收线程。

回收垃圾对象的内存有三种基础算法：

* 内存碎片清除算法，
* 性能开销较大压缩算法，
* 堆使用效率较低复制算法。

Java虚拟机采用分代回收思想，将堆分为新生代和老生代，并且通过在不同代中应用不同的垃圾回收算法。

---

回收垃圾对象的内存共有三种基础算法，分别为：会造成内存碎片的清除算法、性能开销较大的压缩算法、以及堆使用效率较低的复制算法。

通常来说，Java虚拟机会采用分代回收的思想，将堆划分为新生代和老年代，并且通过在不同代中应用不同的垃圾回收算法。

传统的做法是将新生代再划分为Eden区和两个大小一致的Survivor区。在只针对新生代的Minor GC中，Eden区和非空Survivor区的存活对象会被复制到空的Survivor区中，当Survivor区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。

因为Minor GC只针对新生代进行垃圾回收，所以在枚举GC Roots的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代的引用的内存区域。

G1垃圾回收器将堆划分为多个等大的区域，每个区域都可以充当Eden区，Survivor区或者老年代区。G1会优先收集垃圾最多的区域，从而最大化垃圾回收的效益。这也是Garbage First名字的由来。

Java 11中引入的实验性垃圾回收器GC，仅在扫描GC Roots时请求Stop-The-World，暂停应用线程。因此，它宣称可将GC暂停时间控制在10ms以下。ZGC暂时没有应用分代回收的思路，将整个堆空间看成一块，其代价是垃圾回收CPU消耗较高。

### 4.Java内存模型是什么？

** 概括 **

代码通常不会按照书写顺序执行。

原因：

* 编译器重排序，
- 处理器乱序执行，
- 内存系统重排序。

内存系统重排序：

在多处理器体系架构下，每个处理器都可能缓存了一部分数据。由于时刻保持缓存数据与内存数据同步的性能代价太大，因此部分体系架构可能允许缓存数据与内存数据不同步，对Java程序的影响：两个不同的Java线程在同一时间内看到的同一块内存地址中的值可能不同。

Java内存模型：针对上述问题提出一套规范，允许Java程序员更为细致的定义Java程序的内存行为。通过定义一系列的happens-before操作，让应用程序开发者轻易表达不同线程操作之间的内存可见性。

在遵守Java内存模型的前提下，即时编译器以及底层体系架构能够调整内存访问操作，达到性能优化的效果。没有正确利用happens-before规则，将可能导致数据竞争。

Java内存模型：

内存系统重排序：通过内存屏障来禁止重排序。

即时编译器：内存屏障限制重排序优化。

处理器：内存屏障会导致缓存的刷新操作。

---

在现代计算机系统中，代码通常不会按照书写顺序执行。造成这一情况的原因有三个，分别为编译器的重排序，处理器的乱序执行，以及内存系统的重排序。

以内存系统重排序为例，在多处理器体系架构下，每个处理器都可能缓存了一部分数据。由于时刻保持缓存数据与内存数据同步的性能代价太大，因此部分体系架构可能允许缓存数据与内存数据不同步。这对Java程序的影响便是，两个不同的Java线程在同一时间内看到的同一块内存地址中的值可能不同。

Java内存模型是针对上述问题而提出的一套规范，用以允许Java程序员更为细致地定义Java程序的内存行为。它通过定义了一系列的happens-before操作，让应用程序开发者能够轻易地表达不同线程的操作之间的内存可见性。

在遵守Java内存模型的前提下，即时编译器以及底层体系架构能够调整内存访问操作，以达到性能优化的效果。如果开发者没有正确地利用happens-before规则，那么将可能导致数据竞争。

Java内存模型是通过内存屏障来禁止重排序的。对于即时编译器来说，内存屏障将限制它所能做的重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作。
