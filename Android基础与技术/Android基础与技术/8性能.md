## 性能

### 目录

- 1.优化
- 2.内存泄漏

### 优化

布局优化: 减少布局层级，使用ViewStub提高显示速度，布局服用，尽可能少使用warp_content，删除空间中无用的属性,避免过度绘制移除window默认背景，按需显示展位图，自定义View优化，使用canvas.clipRect()识别可见区域

启动速度优化:采用分布加载，异步加载，延期加载提高应用初始化速度，采用线程初始化数据等，合理的刷新机制

内存优化:防止内存泄露,使用一些第三方工具检测解决

代码优化:遵循Java生命周期

安装包优化:删除无用资源，优化图片，代码混淆，避免重复库存在，插件化

CPU占用优化：

### 内存泄漏

是什么：对象无法释放导致内存无法释放。有些对象只有有限的生命周期，当他们的任务完成之后，它们将被垃圾回收，如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，就会导致内存泄露。

为什么：

- 内部类持有外部类引用
- 强引用

- 单例，例如单例中的Context生命周期大于本身Context生命周期
- 线程使用Hander，当activity已经结束，线程依然在运行更新UI
- 非静态类使用静态变量导致无法回收释放
- WebView网页过多
- 资源未关闭，例如数据库使用完之后关闭连接

怎么样/查看和解决：

- 强引用造成内存泄漏用弱引用替代，因为内存泄漏指对象无法释放，用弱引用内存不足时会回收对象。
- 内部类持有外部类引用，用静态内部类替代。因为静态内部类不需要调用外部类对象，不持有外部类引用。如果不使用静态内部类，怎么解决。
- 使用开源框架LeakCanary检测针对性解决

用途/后果：
