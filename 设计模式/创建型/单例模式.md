## 单例模式：

### 是什么：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

特点：

- 单例类只能有一个实例
- 单例类必须创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

### 为什么：为了一个应用程序当中只有一个静态全局的对象，防止创建对象太多降低应用性能。

### 怎么样：

Singleton:单例类。

1.构造器私有化(private):防止外部类实例化该类并调用。

2.声明私有静态变量

3.提供静态获取实例的方法:通过调用Singleton.getInstance()来获取实例对象

代码：Singleton

### 用途/后果：

在一个系统中，要求一个类有且仅有一个对象，具体使用场景如下：

* 整个项目需要一个共享访问点或共享数据。
* 创建一个对象需要耗费的资源过多， 比如访问I/O或者数据库等资源。
* 工具类对象。例如：CrashHandler异常处理工具；CretinAutoUpdate自动增量更新工具类。

### 六种实现方式：

#### 1.饿汉

是什么：类创建的同时就已经创建好一个静态对象供系统使用，即类加载时完成初始化。

怎么样：代码-Singleton1

用途/后果：

- 优点：获取对象速度快；线程安全。
- 缺点：类加载较慢；如果未调用，内存浪费。
- 综合：建议使用。

#### 2.懒汉/懒加载

是什么：声明一个静态对象，用户第一次调用时初始化。

怎么样：代码-Singleton2

用途/后果：

- 优点：节约资源，不会内存浪费。
- 缺点：第一次加载时需要实例化，反应稍慢；线程不安全，并发环境下可能会出现多个Singleton实例。
- 综合：不建议使用。

#### 3.同步锁

是什么：同步是同一时间内的并发量。线程安全是为了保证变量一致性。

怎么样：代码-Singleton3

用途/后果：

- 优点：线程安全。
- 缺点：每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们用不到同步。
- 综合：不建议使用。

#### 4.双重检查锁定/双重检验锁(DCL)

是什么：getSingleton方法中对Singleton进行了两次判空：第一次是为了不必要的同步，第二次是在Singleton等于null的情况下才创建实例。

volatile：为实例域的同步访问提供了一种免锁机制。

在这里使用volatile会或多或少会影响性能，但考虑到程序的正确性，牺牲这点性能是值得的。

怎么样：代码-Singleton4

用途/后果：

- 优点：资源利用率高。第一次执行getInstance时单例对象才被实例化，效率高。根据JVM本身机制，实现了线程安全。
- 缺点：第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷。
- 在一定程度上解决了资源的消耗和多余的同步、线程安全等问题，但其还是在某些情况会出现失效的问题，也就是DCL失效。
- 综合：不建议使用。

#### 5.静态内部类

是什么：第一次加载Singleton类时并不会初始化实例，只有第一次调用getInstance方法时虚拟机加载LazyHolder并初始化实例。

为什么：为了不在初始化的时候加载，调用时加载。

怎么样：代码-Singleton5

用途/后果：不仅能确保线程安全，也能保证Singleton类的唯一性。

- 综合：建议使用。

#### 6.枚举

怎么样：代码-Singleton6

用途/后果：

优点：

- 线程安全，并且在任何情况下都是单例；无构造函数。
- 无偿提供了序列化机制，绝对防止多次实例化，及时面对复杂的序列化或者反射攻击。

问题：单例对象被反序列化时会重新生成对象：

场景：先把文件写入磁盘再读取，会重新获取一个对象。

解决：反序列化操作提供了readResolve方法，可以让开发人员控制对象的反序列化。

代码：Singleton1#readResolve

#### 选择：并发环境，资源消耗。

特殊情况：除了多个类加载器和非要通过反射等手段生成多个对象。

#### 区别：

初始化：

- 饿汉：类加载时初始化。
- 懒汉：用户第一次调用时初始化。

资源加载和性能：

- 饿汉：类加载时实例化一个单例，不管之后用不用，都会占内存。第一次调用也快，资源已加载完成。
- 懒汉：延迟加载，第一次调用才加载单例。
- 同步锁：线程安全，但是每次都要同步，降低性能
- DCL：做了两次null检查，只有第一次调用单例才会做同步，线程安全，避免了每次同步的性能损耗。
- 静态内部类：利用classloader机制来保证初始化单例时只有一个线程，线程安全，同时没有性能损耗。

### 进阶：

《Effective Java》

https://blog.csdn.net/jason0539/article/details/23297037/

### 快问快答：

1.单例模式是什么？解决了什么问题？项目中应用？

是什么：单例模式是一个单例类里只有一个实例，且是唯一的实例，在整个应用程序中也只有一个单例对象。

解决的问题：避免创建许多对象造成资源的浪费。

项目中应用：工具类对象，例如：CrashHandler异常处理工具；CretinAutoUpdate自动增量更新工具类；心神学堂APIManager；或整个项目需要一个共享访问点或共享数据。

2.手写一个你认为可以的单例模式，并解释下静态内部类单例模式，锁的机制。

手写：饿汉模式和静态内部类模式。

静态内部类单例模式：第一次调用的时候初始化实例。

锁的机制：同步是指同一个时刻会有多个并发，不上同步锁，同一个时刻会新建n个实例，上了锁就不会了。

