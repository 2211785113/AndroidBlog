## 代理模式/委托模式：

### 是什么：为其他对象提供一种代理以控制对这个对象的访问。eg：代理上网、打官司

角色：

- 抽象主题类Subject：声明真实主题类与代理类的共同接口方法。
- 真实主题类RealSubject：代理类所代表的真实主题。
- 代理类Proxy：持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行。
- 客户端类Client：通过代理类间接地调用真实主题类的方法。

### 为什么：

A想做某件事情，但是自己不能亲自去做，所以委托代理类B帮忙自己做这件事情，用一个共同接口来给A类和委托代理类B解耦。

核心：从程序结构上使模块之间解耦。

### 怎么样：

分类：

编码角度：

* 静态代理：在代码运行前就已经存在代理类的class编译文件；
* 动态代理：在代码运行时通过反射来动态生成代理类的对象，并确定到底来代理谁。即在编码阶段无须知道代理谁，代码运行时决定代理谁。

适用范围：

* 远程代理：为一个对象在不同的地址空间提供局部代表，这样系统可以将Server部分的实现隐藏。
* 虚拟代理：使用一个代理对象表示一个十分耗费资源的对象并在真正需要时才创建。
* 安全代理：用来控制真实对象访问时的权限。一般用于真实对象有不同的访问权限时。
* 智能指引：当调用真实的对象时，代理处理另外一些事，比如计算真实对象的引用计数，当该对象没有引用时，可以自动释放它；或者访问一个实际对象时，检查是否已经能够锁定它，以确保其他对象不能改变它。

区别：

- 静态代理：编码阶段知道谁代理谁。代理对象持有抽象主题类的引用。
- 动态代理：运行阶段决定谁代理谁。代理对象持有真实主题类的引用，所以用setFactory。

**静态代理：**

**example1：**

需求：A工厂要卖东西，但是自己没有渠道，所以让Leo帮忙去卖东西；B工厂同理，让Mark帮忙去卖东西。

代码：staticProxy

抽象主题类MakeFactory：抽象统一接口卖东西。

真实主题类AFactory/BFactory：实现接口卖东西。

代理类Leo/Mark：持有真实对象的引用。

客户端Client：通过代理类间接调用真实主题类的方法。

**example2：**

需求：我多年没有回过哈尔滨了，很是想念哈尔滨秋林红肠的味道。但是本人工作一直很忙抽不开身，不能亲自回哈尔滨购买，于是就托在哈尔滨的朋友帮我购买秋林红肠。

抽象主题类IShop：具有真实主题类和代理类的共同接口方法，共同的方法就是购买。

真实主题类Wo：实现了IShop接口提供的buy方法。

代理类Other：也实现了IShop接口，同时持有真实主题类，在buy方法中调用了真实主题类的buy方法。

客户端Client：通过代理类间接调用真实主题类的方法。

**动态代理：**

**example2:**

Java提供了动态代理接口InvocationHandler，实现该接口需要重写invoke方法。

动态代理类：声明一个Object引用，该引用指向真实主题类，调用真实主题类的具体方法在invoke方法中执行。

客户端：

生成动态代理类：调用Proxy.newProxyInstance。

调用purchasing的buy方法会调用DynamicPurchasing的invoke方法。

### 用途/后果：

优点：

* 真实主题类就是实现实际的业务逻辑，不用关心其他非本职的工作。
* 真实主题类随时都会发生变化；但是因为它实现了公共的接口，所以代理类可以不做任何修改就能够使用。

### 快问快答：

1.代理模式是什么？解决了什么问题？项目中应用？

是什么：为真实对象提供一种代理以控制对这个对象的访问。

解决的问题：A不能亲自去做这件事情，委托代理类B去做这件事情，用一个共同抽象接口来给A类和代理类B解耦。这样做可以屏蔽真实行为的访问，让程序更加安全，可以对真实行为的调用进行控制。

项目中应用：源码中应用：Retrofit#Call的创建过程使用了动态代理模式。注解的本质也是动态代理。

2.动态代理模式和代理模式有什么区别？动态代理解决了什么问题？

区别：动态代理与代理模式原理是一样的，只是它没有具体的代理类，直接通过反射获取了真实主题类的类加载器和接口生成了一个代理对象。静态代理已经事先知道真实对象的代理类；而动态代理是运行过程中为每一个真实主题类动态生成一个代理类。

解决的问题：动态代理可以直接给某一个目标对象生成一个代理对象，而不需要代理类存在。

3.注解、动态代理和反射的关系：

注解中用到了反射：运行时注解处理器。

动态代理运用反射：获取真实主题类的类加载器和接口(即代理类要实现的接口)来生成代理对象。


