## 网络编程基础知识

### 目录

* 1.网络分层
* 2.TCP协议
* 3.HTTP协议

### 1.网络分层

**是什么：**

网络数据要发送，转发，打包，拆包，以及控制信息的加载或拆出等，需要由不同的硬件和软件模块来完成。

**为什么：**

将通信和网络互联复杂的问题变简单。

**怎么样：**

网络分层每一层都有不同的功能。实现这些功能需要遵守共同的规则，即“协议”。分为5层。

* 物理层：用物理手段把计算机连接起来，负责比特流在节点间的传输，即物理传输。该层协议与链路有关，也与传输介质有关。
* 数据链路层：从网络层接收到数据分割成特定的可被物理层传输的帧，用来保证传输。帧是用来移动数据的结构包，不仅包括原始数据，还包括发送方和接收方的物理地址以及纠错和控制信息；接收方地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达；如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。
* 网络层：建立主机到主机的通信。决定如何将数据从发送方路由到接收方，综合考虑发送优先权、 网络拥塞程度、 服务质量以及可选路由的花费来决定从一个网络中的节点 A 到另一个网络中节点 B 的最佳路径。
* 传输层：两台主机上的应用程序提供端到端的通信。有两个传输协议：TCP传输控制协议和UDP用户数据报协议。TCP是可靠面向连接的协议， UDP是不可靠无连接的协议。
* 应用层：应用程序收到传输层的数据，进行解读。应用层规定了解读应用程序的数据格式，主要协议有HTTP、 FTP、 Telnet、 SMTP、 POP3等。

### 2.TCP协议

流程：打开连接-写请求数据-读请求数据-关闭连接(数据传达完毕则关闭连接)。
![图](https://github.com/2211785113/Blog/blob/master/images/http.jpg)

说明：seq为Sequence Number，ACK为AcknowledgmentNumber

**三次握手过程：**

* 第一次握手：我要发消息。建立连接。客户端发送连接请求报文段，将SYN设置为1，seq设置为x，客户端进入SYN_SENT状态，等待服务端确认。
* 第二次握手：收到。服务器收到客户端SYN报文段，对SYN报文段进行确认，设置ACK为（seq+1）；同时自己还要发送SYN请求信息，将SYN设置为1、seq为y。服务端将上述所有信息放到SYN+ACK报文段中，一并发送给客户端，此时服务端进入SYN_RCVD状态。
* 第三次握手：收到。客户端收到服务端的SYN+ACK报文段；将ACK设置为y+1，向服务端发送ACK报文段，发送完毕后，客户端和服务端都进入ESTABLISHED （ TCP连接成功） 状态， 完成TCP的三次握手。

**四次挥手过程：**

* 第一次挥手： 我没消息要发送了。客户端设置seq和ACK， 向服务端发送一个FIN报文段。 此时， 客户端进入FIN_WAIT_1状态， 表示客户端没有数据要发送给服务端了。
* 第二次挥手： 收到。服务端收到了客户端发送的FIN报文段， 向客户端回了一个ACK报文段。
* 第三次挥手： 我也没消息要发送了。服务端向客户端发送 FIN 报文段， 请求关闭连接， 同时服务端进入LAST_ACK状态。
* 第四次挥手： 收到。客户端收到服务端发送的FIN报文段， 向服务端发送ACK报文段， 然后客户端进入TIME_WAIT状态。 服务端收到客户端的ACK报文段以后， 就关闭连接。 此时， 客户端等待2MSL（ 最大报文段生存时间） 后依然没有收到回复， 则说明服务端已正常关闭， 这样客户端也可以关闭连接了。

**问题1：TCP为什么要进行三次握手？**

因为TCP/IP是端对端的面向对象的可靠的连接，如果两端使用的协议不一样，就不能进行通信，所以三次握手是为了试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了。

**问题2：TCP为什么要进行四次挥手？**

因为TCP/IP是端对端的面向对象的可靠的连接，主机1和主机2断开时，主机1先通知主机2没有要发送的数据，主机2收到，主机2通知主机1也没有要发送的数据，主机1收到，才能安全断开连接。

### 3.HTTP协议

**是什么**

- HTTP协议是超文本传输协议。是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户端需要通过HTTP协议传输所要访问的超文本信息，浏览器需要通过HTTP协议传输响应超文本内容给客户端。
- HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。
- 当我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。
- 当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。

**6个特点：**

* 应用层面向对象协议，配合TCP/IP使用。客户端与服务端建立连接后，通过套接字接口访问TCP。
* 基于C/S架构进行通信：客户端发送请求，服务端响应数据。
* 简单快速：客户端向服务器请求服务时， 只需传送请求方法和路径。 请求方法常用的有GET、 HEAD、POST， 每种方法规定了客户与服务器联系的类型不同。 由于 HTTP 协议简单， 使得HTTP服务器的程序规模小， 因而通信速度很快。
* 灵活：HTTP允许传输任意类型的数据对象。 正在传输的类型由Content-Type加以标记。
* 无状态：同一个客户端的这次请求和上次请求是没有对应关系。协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接，这样可能导致每次连接传送的数据量增大；服务器不需要先前信息验证应答速度会较快。
* 无连接：限制每次连接只处理一个请求。 服务器处理完客户的请求， 并收到客户的应答后， 即断开连接。 采用这种方式可以节省传输时间。

**HTTP URL格式：**

http://host[＂:＂port][abs_path]

通过HTTP协议来定位网络资源:// Internet主机域名或IP地址：端口号，为空使用默认端口80.指定请求资源的URI即Web上任意的可用资源

**HTTP报文：面向文本，报文中的每一个字段都是一些ASCII码串，各个字段的长度不确定。分为请求报文和响应报文。**

1.HTTP请求报文：请求行，请求报头，空行，请求数据。

请求行：Method Request-URI HTTP-Version CRLF 即 请求方法；统一资源标识符URL字段；请求的HTTP协议版本；回车和换行(除了作为结尾的CRLF外，不允许出现单独的CR或LF字符)。例子：GET http://blog.csdn.net/itachi85 HTTP/1.1

8种请求方法：GET(常用)、 POST(常用)、 HEAD、 PUT、 DELETE、 TRACE、 CONNECT、OPTIONS。

* GET：请求获取Request-URI所标识的资源。
* POST：在Request-URI所标识的资源后附加新的数据。
* HEAD：请求获取由Request-URI所标识的资源的响应消息报头。
* PUT：请求服务器存储一个资源， 并用Request-URI作为其标识。
* DELETE：请求服务器删除Request-URI所标识的资源。
* TRACE：请求服务器回送收到的请求信息， 主要用于测试或诊断。
* CONNECT：HTTP 1.1协议中预留给能够将连接改为管道方式的代理服务器。
* OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。

请求数据：不在GET方法中使用，在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求报头是Content-Type和Content-Length。

2.HTTP响应报文：状态行，响应报头，空行，响应正文。

状态行：HTTP-Version Status-Code Reason-Phrase CRLF 即 服务器HTTP协议版本；服务器发回的响应状态码；状态码的文本描述；回车换行。例子：HTTP/1.1 200 OK

状态码：由3位数字组成，第一个数字定义了响应的类别，且有以下5种可能取值。

* 100～199： 指示信息， 收到请求， 需要请求者继续执行操作。1xx（临时响应）
* 200～299： 请求成功， 请求已被成功接收并处理。2xx（成功）
* 300～399： 重定向， 要完成请求必须进行更进一步的操作。3xx（已重定向）
* 400～499： 客户端错误， 请求有语法错误或请求无法实现。4xx（请求错误）
* 500～599： 服务器错误， 服务器不能实现合法的请求。5xx（服务器错误）

常见状态码：

* 200 OK：客户端请求成功。
* 400 Bad Request：客户端请求有语法错误，服务器无法理解。
* 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用。
* 403 Forbidden：服务器收到请求， 但是拒绝提供服务。
* 500 Internal Server Error：服务器内部错误，无法完成请求。
* 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

![HTTP请求报文]{https://github.com/2211785113/Blog/blob/master/images/http_req_msg.jpg}
![HTTP响应报文]{https://github.com/2211785113/Blog/blob/master/images/http_res_msg.jpg}

**HTTP消息报头：有0个或多个请求报头，每个请求报头由键值对组成，每行一对，关键字和值用英文冒号“:”分隔**

1.通用报头：既可以出现在请求报头，也可以出现在响应报头。

* Date：表示消息产生的日期和时间。
* Connection：允许发送指定连接的选项。例如指定连接是连续的；或者指定“close”选项，通知服务器，在响应完成后，关闭连接。
* Cache-Control：用于指定缓存指令，缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现),且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制)。(常用)

2.请求报头：通知服务器关于客户端请求的信息。

* Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
* User-Agent：发送请求的浏览器类型、操作系统等信息。
* Accept：客户端可识别的内容类型列表，用于指定客户端接收哪些类型的信息。
* Accept-Encoding：客户端可识别的数据编码。
* Accept-Language：表示浏览器所支持的语言类型。
* Connection：允许客户端和服务器指定与请求/响应连接有关的选项。例如，这时为Keep-Alive则表示保持连接。或者close。(常用)
* Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。
* Cookie：网站进行Session跟踪而储存在用户本地终端上的数据。(常用)

3.响应报头：用于服务器传递自身信息的响应。

* Location：用于重定向接收者到一个新的位置，常用在更换域名的时候。
* Server：包含服务器用来处理请求的系统信息，与请求报头User-Agent相对应。

4.实体报头：用来定义被传送资源的信息，既可用于请求也可用于响应。请求和响应消息都可以传送一个实体。

* Content-Type：发送给接收者的实体正文的媒体类型。
* Content-Length：正文的长度。
* Content-Language：描述资源所用的自然语言。
* Content-Encoding：实体报头被用作媒体类型的修饰符。它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。
* Last-Modified：实体报头用于指示资源的最后修改日期和时间。
* Expires：实体报头给出响应过期的日期和时间。

**抓包**

是什么：将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，用来数据截取或检查网络安全。用来查看请求网络的请求报文和响应报文。

怎么样：Windows-Fiddler；Mac-Charles。web端Chrome DevTools用来网页制作和调试。

**问题1：既然TCP/UDP是广泛使用的网络通信协议，那为啥还要多出个http协议来呢？**

一个场景：如果客户端同时十万人请求服务器端，那么客户端与服务器就会一直保持连接，服务器满足不了承载。所以有了HTTP协议，基于可靠的TCP协议，并且是无状态的，即客户端请求之后，服务端立即断开连接，释放资源，保证了资源的利用，也吸取了TCP可靠的优点。

**问题2：如果有大量的连接，每次在连接、关闭时都要经历三次握手、四次挥手，很显然会造成性能低下。/如果一个网页一直要浏览40分钟呢，不能得到请求数据就断开吧？**

HTTP有一种叫作keepalive connections的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下来的连接而无须再次握手。
![图](https://github.com/2211785113/Blog/blob/master/images/http_keep-alive.jpg)

**问题3：Cookie机制是用来干什么的？**

http协议是无状态的，同一个客户端的这次请求和上次请求没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。为了解决这个问题，Web程序引入了Cookie机制来维护状态。

### 快问快答

1.一个完整的Http请求是怎样的？(有疑问点请自行百度)

- 对网址进行DNS域名解析，得到对应的IP地址 ->
- 根据IP地址找到对应服务器，发起TCP的三次握手 -> 建立TCP连接后，应用层客户端发起http请求 ->
- 服务器写入请求数据，读取完请求数据，应用层服务端响应http请求 -> 传输层TCP进行四次挥手，并关闭连接
- 浏览器解析html代码，并请求html中的资源 -> 浏览器对界面进行渲染并呈现给用户

本质：请求-处理-响应

涨知识：服务器接收到http请求后，会进行负载均衡，把短时间内较高的访问量分摊到不同机器上处理。

待总结(https原理，心跳机制)：https://blog.csdn.net/weixiao1999/article/details/88858592

心跳机制：定时时间段内发送一些无意义的数据，保持连接不被闲置。

为什么要发送心跳包？