## 七大查找算法：

介绍：https://www.cnblogs.com/maybe2030/p/4715035.html

书籍：《大话数据结构》

### 1.顺序查找

类型：无序查找。

是什么：查找某元素在数组中的位置。

怎么样：循环遍历查找。

代码：SequenceSearch

时间复杂度：T(N)=O(N)

本质：遍历

### 2.二分查找/折半查找

类型：有序查找。(先排序)

是什么：二分查找，静态查找效率不错，动态查找不建议使用。

怎么样：要查找的数不断与中间的数mid值进行对比。

mid取值：mid=(left+right)/2=left+1/2*(right-left)

代码：BinarySearch

时间复杂度：T(N)=O(log2N)

本质：折半。

### 3.插值查找

类型：有序查找。(先排序)

是什么：基于二分查找，将查找点的选择改为自适应选择。

为什么：对于表长大，关键字分布比较均匀的查找表，插值查找比二分查找效率高。

怎么样：要查找的数不断与mid进行对比,让mid值更靠近要查找的值。

mid取值：mid=left+(value-arr[left])/(arr[right]-arr[left])*(right-left)

代码：InsertSearch

时间复杂度：T(N)=O(log2(log2N))

本质：折半。

### 4.斐波那契查找

类型：有序查找。

是什么：斐波那契数列：从第三个数开始，后边每一个数都是前两个数的和。

为什么：基于二分查找，查找点的选择根据斐波那契数列进行分割。

怎么样：

* 在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，
* 将原查找表扩展为长度为F[n](如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，
* 完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，
* 后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。

代码：FibonacciSearch

时间复杂度：T(N)=O(log2N)

本质：斐波那契序列。

链接：https://www.cnblogs.com/lpfuture/p/7112450.html

### 5.树表查找

类型1：二叉查找树/二叉搜索树/BST(binary search tree)

是什么：左结点的值小于根结点的值，右结点的值大于根结点的值。对二叉查找树进行中序遍历即可得到有序数列。

类型2：平衡查找树之2-3查找树(2-3 Tree)

是什么：中序遍历2-3查找树，就可以得到有序序列。

类型3：平衡查找树之红黑树(Red-Black Tree)

是什么：

* 红黑树是一种具有红色和黑色链接的平衡查找树。
* 整个树完全黑色平衡，即从根节点到所有叶子结点的路径上，黑色链接的个数都相同(从根节点到叶子节点的距离都相等)

类型4：B树和B+树(B Tree/B+ Tree)

是什么：一个节点可以拥有多于2个子节点的二叉查找树

### 6.分块查找/索引顺序查找

是什么：将n个数据元素"按块有序"划分为m块（m ≤ n）。

### 7.哈希查找
是什么：

哈希表是一个在时间和空间上做出权衡的经典例子。

如果没有内存限制，那么可以直接将键作为数组的索引，那么所有的查找时间复杂度为O(1)；

如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。

哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。

只需要调整哈希函数算法即可在时间和空间上做出取舍。
